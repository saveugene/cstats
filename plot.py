#!/usr/bin/env python3
"""Interactive container stats dashboard (Plotly)."""

from __future__ import annotations

import argparse
import html
import webbrowser
from http import HTTPStatus
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer
from pathlib import Path

import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Distinct, colorblind-friendly palette.
COLORS = [
    "#636EFA",
    "#EF553B",
    "#00CC96",
    "#AB63FA",
    "#FFA15A",
    "#19D3F3",
    "#FF6692",
    "#B6E880",
    "#FF97FF",
    "#FECB52",
]


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Render container stats dashboard from CSV.")
    parser.add_argument(
        "csv_path",
        nargs="?",
        default="docker-stats.csv",
        help="Path to CSV generated by monitor/daemon.sh or monitor/k8s-daemon.sh",
    )
    parser.add_argument(
        "--live",
        action="store_true",
        help="Serve dashboard that updates graph in-place (no page reload).",
    )
    parser.add_argument(
        "--interval",
        type=float,
        default=2.0,
        help="Refresh interval in seconds for --live mode (default: 2.0)",
    )
    parser.add_argument(
        "--host",
        default="127.0.0.1",
        help="Host for live dashboard server (default: 127.0.0.1)",
    )
    parser.add_argument(
        "--port",
        type=int,
        default=8088,
        help="Port for live dashboard server (default: 8051)",
    )
    parser.add_argument(
        "--no-open-browser",
        action="store_true",
        help="Do not auto-open browser in --live mode.",
    )
    return parser.parse_args()


def empty_figure() -> go.Figure:
    fig = go.Figure()
    fig.update_layout(
        template="plotly_dark",
        title=dict(text="Container Resource Monitor", font=dict(size=20)),
        height=600,
        width=1200,
    )
    fig.add_annotation(
        x=0.5,
        y=0.5,
        xref="paper",
        yref="paper",
        showarrow=False,
        font=dict(size=18),
        text="No metrics yet. Start monitor/daemon.sh or monitor/k8s-daemon.sh and wait for samples.",
    )
    return fig


def build_figure(df: pd.DataFrame) -> go.Figure:
    if df.empty or "container" not in df:
        return empty_figure()

    containers = sorted(df["container"].dropna().unique())
    if not containers:
        return empty_figure()

    color_map = {container: COLORS[index % len(COLORS)] for index, container in enumerate(containers)}

    fig = make_subplots(
        rows=3,
        cols=2,
        row_heights=[0.4, 0.4, 0.2],
        column_widths=[0.7, 0.3],
        subplot_titles=(
            "CPU %",
            "CPU - peak & average",
            "RAM (MB)",
            "RAM - peak & average",
            "Memory % of limit",
            "",
        ),
        specs=[
            [{"type": "scatter"}, {"type": "bar"}],
            [{"type": "scatter"}, {"type": "bar"}],
            [{"type": "scatter"}, {"type": "table"}],
        ],
        vertical_spacing=0.08,
        horizontal_spacing=0.08,
    )

    for name in containers:
        container_df = df[df["container"] == name].sort_values("timestamp")
        color = color_map[name]

        fig.add_trace(
            go.Scatter(
                x=container_df["timestamp"],
                y=container_df["cpu_pct"],
                name=name,
                legendgroup=name,
                showlegend=True,
                mode="lines+markers",
                marker=dict(size=3),
                line=dict(color=color, width=1.5),
                hovertemplate="%{x|%H:%M:%S}<br>CPU: %{y:.1f}%<extra>" + name + "</extra>",
            ),
            row=1,
            col=1,
        )

        fig.add_trace(
            go.Scatter(
                x=container_df["timestamp"],
                y=container_df["mem_usage_mb"],
                name=name,
                legendgroup=name,
                showlegend=False,
                mode="lines+markers",
                marker=dict(size=3),
                line=dict(color=color, width=1.5),
                hovertemplate="%{x|%H:%M:%S}<br>RAM: %{y:.1f} MB<extra>" + name + "</extra>",
            ),
            row=2,
            col=1,
        )

        fig.add_trace(
            go.Scatter(
                x=container_df["timestamp"],
                y=container_df["mem_pct"],
                name=name,
                legendgroup=name,
                showlegend=False,
                mode="lines+markers",
                marker=dict(size=3),
                line=dict(color=color, width=1.5),
                hovertemplate="%{x|%H:%M:%S}<br>Mem: %{y:.2f}%<extra>" + name + "</extra>",
            ),
            row=3,
            col=1,
        )

    summary = (
        df.groupby("container")
        .agg(
            cpu_max=("cpu_pct", "max"),
            cpu_avg=("cpu_pct", "mean"),
            mem_max=("mem_usage_mb", "max"),
            mem_avg=("mem_usage_mb", "mean"),
        )
        .reindex(containers)
    )

    fig.add_trace(
        go.Bar(
            x=summary.index,
            y=summary["cpu_max"],
            name="peak",
            marker_color="rgba(239,85,59,0.7)",
            showlegend=False,
            hovertemplate="%{x}<br>Peak CPU: %{y:.1f}%<extra></extra>",
        ),
        row=1,
        col=2,
    )
    fig.add_trace(
        go.Bar(
            x=summary.index,
            y=summary["cpu_avg"],
            name="avg",
            marker_color="rgba(99,110,250,0.7)",
            showlegend=False,
            hovertemplate="%{x}<br>Avg CPU: %{y:.1f}%<extra></extra>",
        ),
        row=1,
        col=2,
    )
    fig.add_trace(
        go.Bar(
            x=summary.index,
            y=summary["mem_max"],
            name="peak",
            marker_color="rgba(239,85,59,0.7)",
            showlegend=False,
            hovertemplate="%{x}<br>Peak RAM: %{y:.1f} MB<extra></extra>",
        ),
        row=2,
        col=2,
    )
    fig.add_trace(
        go.Bar(
            x=summary.index,
            y=summary["mem_avg"],
            name="avg",
            marker_color="rgba(99,110,250,0.7)",
            showlegend=False,
            hovertemplate="%{x}<br>Avg RAM: %{y:.1f} MB<extra></extra>",
        ),
        row=2,
        col=2,
    )

    table_summary = (
        df.groupby("container")
        .agg(
            cpu_avg=("cpu_pct", "mean"),
            cpu_max=("cpu_pct", "max"),
            mem_avg=("mem_usage_mb", "mean"),
            mem_max=("mem_usage_mb", "max"),
            mem_pct_max=("mem_pct", "max"),
        )
        .reindex(containers)
    )

    fig.add_trace(
        go.Table(
            header=dict(
                values=["Container", "CPU avg%", "CPU max%", "RAM avg MB", "RAM max MB", "Mem max%"],
                fill_color="#2a2a2a",
                font=dict(color="white", size=11),
                align="left",
            ),
            cells=dict(
                values=[
                    table_summary.index,
                    table_summary["cpu_avg"].round(1),
                    table_summary["cpu_max"].round(1),
                    table_summary["mem_avg"].round(1),
                    table_summary["mem_max"].round(1),
                    table_summary["mem_pct_max"].round(2),
                ],
                fill_color="#1e1e1e",
                font=dict(color="#ddd", size=10),
                align="left",
            ),
        ),
        row=3,
        col=2,
    )

    fig.update_layout(
        template="plotly_dark",
        title=dict(text="Container Resource Monitor", font=dict(size=20)),
        height=950,
        width=1400,
        uirevision="live-monitor",
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="center",
            x=0.35,
            font=dict(size=10),
        ),
        barmode="group",
        hovermode="x unified",
    )

    fig.update_yaxes(title_text="CPU %", row=1, col=1)
    fig.update_yaxes(title_text="MB", row=2, col=1)
    fig.update_yaxes(title_text="Mem %", row=3, col=1)
    fig.update_xaxes(title_text="Time", row=3, col=1)
    fig.update_xaxes(rangeslider=dict(visible=True, thickness=0.05), row=3, col=1)
    fig.update_xaxes(tickangle=-35, row=1, col=2)
    fig.update_xaxes(tickangle=-35, row=2, col=2)

    return fig


def write_html(fig: go.Figure, out_html: Path) -> None:
    fig.write_html(str(out_html))


def load_dataframe(csv_path: Path) -> pd.DataFrame:
    try:
        return pd.read_csv(csv_path, parse_dates=["timestamp"])
    except (FileNotFoundError, pd.errors.EmptyDataError):
        return pd.DataFrame(columns=["timestamp", "container", "cpu_pct", "mem_usage_mb", "mem_limit_mb", "mem_pct"])


def run_once(csv_path: Path) -> None:
    if not csv_path.exists():
        raise FileNotFoundError(f"CSV file not found: {csv_path}")

    df = load_dataframe(csv_path)
    fig = build_figure(df)
    out_html = csv_path.with_suffix(".html")
    write_html(fig, out_html)
    print(f"Saved interactive dashboard -> {out_html}")

    # try:
    #     out_png = csv_path.with_suffix(".png")
    #     fig.write_image(str(out_png), scale=2)
    #     print(f"Saved static image       -> {out_png}")
    # except Exception:
    #     print("(install kaleido for PNG export: pip install kaleido)")

    try:
        fig.show()
    except Exception as exc:
        print(f"(could not open browser automatically: {exc})")


def live_index_html(interval: float, csv_path: Path) -> str:
    refresh_ms = max(int(interval * 1000), 500)
    escaped_csv_path = html.escape(str(csv_path))
    return f"""<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Container Monitor Live</title>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    body {{
      margin: 0;
      padding: 12px;
      background: #11161d;
      color: #dce3f0;
      font: 13px/1.4 -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }}
    .meta {{
      margin-bottom: 8px;
      opacity: 0.9;
    }}
    #chart {{
      width: 100%;
      height: calc(100vh - 56px);
      min-height: 560px;
      border-radius: 8px;
      overflow: hidden;
      background: #0f141b;
      border: 1px solid rgba(120, 140, 170, 0.25);
    }}
    code {{
      color: #8ed7ff;
    }}
  </style>
</head>
<body>
  <div class="meta">
    Source: <code>{escaped_csv_path}</code>
    | Refresh: <code>{interval:.1f}s</code>
    | Last update: <span id="updated">-</span>
  </div>
  <div id="chart"></div>
  <script>
    const REFRESH_MS = {refresh_ms};
    const chart = document.getElementById("chart");
    const updated = document.getElementById("updated");

    async function updateFigure() {{
      try {{
        const response = await fetch("/api/figure?ts=" + Date.now(), {{ cache: "no-store" }});
        if (!response.ok) {{
          throw new Error("HTTP " + response.status);
        }}
        const figure = await response.json();
        Plotly.react(chart, figure.data, figure.layout, {{
          responsive: true,
          displaylogo: false,
          scrollZoom: true
        }});
        updated.textContent = new Date().toLocaleTimeString();
      }} catch (error) {{
        updated.textContent = "update failed: " + error.message;
      }}
    }}

    updateFigure();
    setInterval(updateFigure, REFRESH_MS);
    window.addEventListener("resize", () => Plotly.Plots.resize(chart));
  </script>
</body>
</html>"""


def make_live_handler(csv_path: Path, interval: float) -> type[BaseHTTPRequestHandler]:
    class LiveHandler(BaseHTTPRequestHandler):
        def do_GET(self) -> None:  # noqa: N802
            path = self.path.split("?", 1)[0]

            if path in ("/", "/index.html"):
                body = live_index_html(interval, csv_path).encode("utf-8")
                self.send_response(HTTPStatus.OK)
                self.send_header("Content-Type", "text/html; charset=utf-8")
                self.send_header("Cache-Control", "no-store")
                self.send_header("Content-Length", str(len(body)))
                self.end_headers()
                self.wfile.write(body)
                return

            if path == "/api/figure":
                df = load_dataframe(csv_path)
                fig = build_figure(df)
                body = fig.to_json().encode("utf-8")
                self.send_response(HTTPStatus.OK)
                self.send_header("Content-Type", "application/json; charset=utf-8")
                self.send_header("Cache-Control", "no-store")
                self.send_header("Content-Length", str(len(body)))
                self.end_headers()
                self.wfile.write(body)
                return

            self.send_error(HTTPStatus.NOT_FOUND, "Not Found")

        def log_message(self, format: str, *args: object) -> None:
            return

    return LiveHandler


def run_live(csv_path: Path, interval: float, host: str, port: int, open_browser: bool) -> None:
    print(f"Live mode: http://{host}:{port}")
    print(f"Source CSV: {csv_path}")
    print(f"Refresh interval: {interval:.1f}s")
    print("Press Ctrl+C to stop")

    try:
        server = ThreadingHTTPServer((host, port), make_live_handler(csv_path, interval))
    except OSError as exc:
        raise RuntimeError(
            f"Could not start live server on {host}:{port}: {exc}"
        ) from exc
    try:
        if open_browser:
            try:
                webbrowser.open(f"http://{host}:{port}")
            except Exception as exc:
                print(f"(could not open browser automatically: {exc})")
        server.serve_forever(poll_interval=0.5)
    finally:
        server.server_close()


def main() -> None:
    args = parse_args()
    csv_path = Path(args.csv_path)

    if args.live:
        if args.interval <= 0:
            raise ValueError("--interval must be > 0")
        run_live(
            csv_path=csv_path,
            interval=args.interval,
            host=args.host,
            port=args.port,
            open_browser=not args.no_open_browser,
        )
        return

    run_once(csv_path)


if __name__ == "__main__":
    try:
        main()
    except RuntimeError as exc:
        print(exc)
    except KeyboardInterrupt:
        print("\nStopped")
